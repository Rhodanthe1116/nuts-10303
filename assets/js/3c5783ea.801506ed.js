(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{129:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),c=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=c(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),b=a,m=d["".concat(s,".").concat(b)]||d[b]||u[b]||i;return n?r.a.createElement(m,l(l({ref:t},p),{},{components:n})):r.a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=b;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},90:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return c}));var a=n(3),r=n(8),i=(n(0),n(129)),s={title:"\u7b2c\u4e8c\u6b65\uff1a\u52a0\u5165\u7cbe\u9748\u5716\uff08Sprites\uff09"},l={unversionedId:"step-02",id:"step-02",isDocsHomePage:!1,title:"\u7b2c\u4e8c\u6b65\uff1a\u52a0\u5165\u7cbe\u9748\u5716\uff08Sprites\uff09",description:"\u63a5\u4e0b\u4f86\u6211\u5011\u8981\u52a0\u5165\u4e00\u4e9b",source:"@site/game/step-02.md",slug:"/step-02",permalink:"/game/step-02",editUrl:"https://github.com/Rhodanthe1116/nuts-10303/edit/master/game/step-02.md",version:"current",sidebar:"someSidebar",previous:{title:"\u7b2c\u4e00\u6b65\uff1a\u5b89\u88dd\u8207\u5efa\u7acb\u8996\u7a97",permalink:"/game/step-01"}},o=[{value:"Setup vs. Init",id:"setup-vs-init",children:[]},{value:"Sprite Lists",id:"sprite-lists",children:[]},{value:"Add Sprites to the Game",id:"add-sprites-to-the-game",children:[]}],p={toc:o};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"\u63a5\u4e0b\u4f86\u6211\u5011\u8981\u52a0\u5165\u4e00\u4e9b\n",Object(i.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Sprite_(computer_graphics)"},"\u7cbe\u9748\u5716\uff08sprites\uff09"),"\u3002\n\u7cbe\u9748\u5716\u662f\u53ef\u4ee5\u5728\u756b\u9762\u4e0a\u5448\u73fe\u4e26\u4e92\u52d5\u7684\u5716\u50cf\u3002"),Object(i.b)("p",null,Object(i.b)("img",{parentName:"p",src:"https://arcade.academy/_images/listing_02.png",alt:"image"})),Object(i.b)("h2",{id:"setup-vs-init"},"Setup vs. Init"),Object(i.b)("hr",null),Object(i.b)("p",null,"In the next code example, ",Object(i.b)("inlineCode",{parentName:"p"},"02_draw_sprites"),", we'll have both an\n",Object(i.b)("inlineCode",{parentName:"p"},"__init__")," method and a ",Object(i.b)("inlineCode",{parentName:"p"},"setup"),"."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"__init__")," creates the variables. The variables are set to values\nsuch as 0 or ",Object(i.b)("inlineCode",{parentName:"p"},"None"),". The ",Object(i.b)("inlineCode",{parentName:"p"},"setup")," actually creates the object instances,\nsuch as graphical sprites."),Object(i.b)("p",null,'I often get the very reasonable question, "Why have two methods? Why not\njust put everything into ',Object(i.b)("inlineCode",{parentName:"p"},"__init__"),"? Seems like we are doing twice the\nwork.\" Here's why. With a ",Object(i.b)("inlineCode",{parentName:"p"},"setup"),' method split out, later on we can\neasily add "restart/play again" functionality to the game. A simple call\nto ',Object(i.b)("inlineCode",{parentName:"p"},"setup")," will reset everything. Later, we can expand our game with\ndifferent levels, and have functions such as ",Object(i.b)("inlineCode",{parentName:"p"},"setup_level_1")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"setup_level_2"),"."),Object(i.b)("h2",{id:"sprite-lists"},"Sprite Lists"),Object(i.b)("p",null,"Sprites are managed in lists. The ",Object(i.b)("inlineCode",{parentName:"p"},"SpriteList")," class optimizes drawing,\nmovement, and collision detection."),Object(i.b)("p",null,"We are using three logical groups in our game. A ",Object(i.b)("inlineCode",{parentName:"p"},"player_list")," for the\nplayer. A ",Object(i.b)("inlineCode",{parentName:"p"},"wall_list")," for walls we can't move through. And finally a\n",Object(i.b)("inlineCode",{parentName:"p"},"coin_list")," for coins we can pick up."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-{.sourceCode",metastring:".}",".}":!0},"self.player_list = arcade.SpriteList()\nself.wall_list = arcade.SpriteList(use_spatial_hash=True)\nself.coin_list = arcade.SpriteList(use_spatial_hash=True)\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-py"},'"""\nPlatformer Game\n"""\nimport arcade\n\n# Constants\nSCREEN_WIDTH = 1000\nSCREEN_HEIGHT = 650\nSCREEN_TITLE = "Platformer"\n\n# Constants used to scale our sprites from their original size\nCHARACTER_SCALING = 1\nTILE_SCALING = 0.5\nCOIN_SCALING = 0.5\n\n\nclass MyGame(arcade.Window):\n    """\n    Main application class.\n    """\n\n    def __init__(self):\n\n        # Call the parent class and set up the window\n        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n\n        arcade.set_background_color(arcade.csscolor.CORNFLOWER_BLUE)\n\n    def setup(self):\n        """ Set up the game here. Call this function to restart the game. """\n        # Create the Sprite lists\n        self.player_list = arcade.SpriteList()\n        image_source = ":resources:images/animated_characters/female_adventurer/femaleAdventurer_idle.png"\n        self.player_sprite = arcade.Sprite(image_source, CHARACTER_SCALING)\n        self.player_sprite.center_x = 64\n        self.player_sprite.center_y = 128\n        self.player_list.append(self.player_sprite)\n\n    def on_draw(self):\n        """ Render the screen. """\n\n        # Clear the screen to the background color\n        arcade.start_render()\n\n        # Draw our sprites\n        self.player_list.draw()\n\n\ndef main():\n    """ Main method """\n    window = MyGame()\n    window.setup()\n    arcade.run()\n\n\nif __name__ == "__main__":\n    main()\n\n')),Object(i.b)("p",null,"Sprite lists have an option to use something called \"spatial hashing.\"\nSpatial hashing speeds the time it takes to find collisions, but\nincreases the time it takes to move a sprite. Since I don't expect most\nof my walls or coins to move, I'll turn on spatial hashing for these\nlists. My player moves around a lot, so I'll leave it off for her."),Object(i.b)("h2",{id:"add-sprites-to-the-game"},"Add Sprites to the Game"),Object(i.b)("p",null,"To create sprites we'll use the ",Object(i.b)("inlineCode",{parentName:"p"},"arcade.Sprite")," class. We can create an\ninstance of the sprite class with code like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-{.sourceCode",metastring:".}",".}":!0},'self.player_sprite = arcade.Sprite("images/player_1/player_stand.png", CHARACTER_SCALING)\n')),Object(i.b)("p",null,"The first parameter is a string or path to the image you want it to\nload. An optional second parameter will scale the sprite up or down. If\nthe second parameter (in this case a constant ",Object(i.b)("inlineCode",{parentName:"p"},"CHARACTER_SCALING"),") is\nset to 0.5, and the the sprite is 128x128, then both width and height\nwill be scaled down 50% for a 64x64 sprite."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"Built-in Resources")),Object(i.b)("p",{parentName:"blockquote"},"The arcade library has a few built-in resources so we can run examples\nwithout downloading images. If you see code samples where sprites are\nloaded beginning with \"resources\", that's what's being referenced.")),Object(i.b)("p",null,"Next, we need to tell ",Object(i.b)("em",{parentName:"p"},"where")," the sprite goes. You can use the\nattributes ",Object(i.b)("inlineCode",{parentName:"p"},"center_x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"center_y")," to position the sprite. You can\nalso use ",Object(i.b)("inlineCode",{parentName:"p"},"top"),", ",Object(i.b)("inlineCode",{parentName:"p"},"bottom"),", ",Object(i.b)("inlineCode",{parentName:"p"},"left"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"right")," to get or set the sprites\nlocation by an edge instead of the center. You can also use ",Object(i.b)("inlineCode",{parentName:"p"},"position"),"\nattribute to set both the x and y at the same time."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-{.sourceCode",metastring:".}",".}":!0},"self.player_sprite.center_x = 64\nself.player_sprite.center_y = 120\n")),Object(i.b)("p",null,"Finally, all instances of the ",Object(i.b)("inlineCode",{parentName:"p"},"Sprite")," class need to go in a\n",Object(i.b)("inlineCode",{parentName:"p"},"SpriteList")," class."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-{.sourceCode",metastring:".}",".}":!0},"self.player_list.append(self.player_sprite)\n")),Object(i.b)("p",null,"We manage groups of sprites by the list that they are in. In the example\nbelow there's a ",Object(i.b)("inlineCode",{parentName:"p"},"wall_list")," that will hold everything that the player\ncharacter can't walk through, and a ",Object(i.b)("inlineCode",{parentName:"p"},"coin_list")," for sprites we can pick\nup to get points. There's also a ",Object(i.b)("inlineCode",{parentName:"p"},"player_list")," which holds only the\nplayer."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Documentation for the [Sprite"),Object(i.b)("li",{parentName:"ul"},"Documentation for the [SpriteList")),Object(i.b)("p",null,"Notice that the code creates ",Object(i.b)("inlineCode",{parentName:"p"},"Sprites")," three ways:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Creating a ",Object(i.b)("inlineCode",{parentName:"li"},"Sprite")," class, positioning it, adding it to the list"),Object(i.b)("li",{parentName:"ul"},"Create a series of sprites in a loop"),Object(i.b)("li",{parentName:"ul"},"Create a series of sprites using coordinates")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"note")),Object(i.b)("p",{parentName:"blockquote"},"Once the code example is up and working:"),Object(i.b)("ul",{parentName:"blockquote"},Object(i.b)("li",{parentName:"ul"},"Adjust the code and try putting sprites in new positions."),Object(i.b)("li",{parentName:"ul"},"Use different images for sprites (see the images folder)."),Object(i.b)("li",{parentName:"ul"},"Practice placing individually, via a loop, and by coordinates in a\nlist."))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-py",metastring:"{11-14,27-34,38-70,78-81}","{11-14,27-34,38-70,78-81}":!0},'"""\nPlatformer Game\n"""\nimport arcade\n\n# Constants\nSCREEN_WIDTH = 1000\nSCREEN_HEIGHT = 650\nSCREEN_TITLE = "Platformer"\n\n# Constants used to scale our sprites from their original size\nCHARACTER_SCALING = 1\nTILE_SCALING = 0.5\nCOIN_SCALING = 0.5\n\n\nclass MyGame(arcade.Window):\n    """\n    Main application class.\n    """\n\n    def __init__(self):\n\n        # Call the parent class and set up the window\n        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n\n        # These are \'lists\' that keep track of our sprites. Each sprite should\n        # go into a list.\n        self.coin_list = None\n        self.wall_list = None\n        self.player_list = None\n\n        # Separate variable that holds the player sprite\n        self.player_sprite = None\n\n        arcade.set_background_color(arcade.csscolor.CORNFLOWER_BLUE)\n\n    def setup(self):\n        """ Set up the game here. Call this function to restart the game. """\n        # Create the Sprite lists\n        self.player_list = arcade.SpriteList()\n        self.wall_list = arcade.SpriteList(use_spatial_hash=True)\n        self.coin_list = arcade.SpriteList(use_spatial_hash=True)\n\n        # Set up the player, specifically placing it at these coordinates.\n        image_source = ":resources:images/animated_characters/female_adventurer/femaleAdventurer_idle.png"\n        self.player_sprite = arcade.Sprite(image_source, CHARACTER_SCALING)\n        self.player_sprite.center_x = 64\n        self.player_sprite.center_y = 128\n        self.player_list.append(self.player_sprite)\n\n        # Create the ground\n        # This shows using a loop to place multiple sprites horizontally\n        for x in range(0, 1250, 64):\n            wall = arcade.Sprite(":resources:images/tiles/grassMid.png", TILE_SCALING)\n            wall.center_x = x\n            wall.center_y = 32\n            self.wall_list.append(wall)\n\n        # Put some crates on the ground\n        # This shows using a coordinate list to place sprites\n        coordinate_list = [[512, 96],\n                           [256, 96],\n                           [768, 96]]\n\n        for coordinate in coordinate_list:\n            # Add a crate on the ground\n            wall = arcade.Sprite(":resources:images/tiles/boxCrate_double.png", TILE_SCALING)\n            wall.position = coordinate\n            self.wall_list.append(wall)\n\n    def on_draw(self):\n        """ Render the screen. """\n\n        # Clear the screen to the background color\n        arcade.start_render()\n\n        # Draw our sprites\n        self.wall_list.draw()\n        self.coin_list.draw()\n        self.player_list.draw()\n\n\ndef main():\n    """ Main method """\n    window = MyGame()\n    window.setup()\n    arcade.run()\n\n\nif __name__ == "__main__":\n    main()\n')))}c.isMDXComponent=!0}}]);